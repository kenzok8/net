name: "Auto Update Net Packages"
on:
  repository_dispatch:
  workflow_dispatch:
    inputs:
      ssh:
        description: 'SSH connection to Actions'
        required: false
        default: 'false'
  schedule:
    - cron: "0 0 * * *"
env:
  TZ: Asia/Shanghai

permissions:
  contents: write

jobs:
  job_init:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Initialization environment
        run: |
          sudo timedatectl set-timezone "$TZ"

      - name: Delete workflow runs
        uses: Mattraks/delete-workflow-runs@main
        with:
          token: ${{ github.token }}
          repository: ${{ github.repository }}
          retain_days: 1
          keep_minimum_runs: 1
        
      - name: SSH connection to Actions
        uses: kenzok78/ssh-action@master
        if: (github.event.inputs.ssh == 'true' && github.event.inputs.ssh  != 'false') || contains(github.event.action, 'ssh')

  job_auto_update_net_packages:
    needs: job_init
    runs-on: ubuntu-latest
    name: update-net-packages
    steps:
      - name: Checkout with full history
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # 获取完整的Git历史记录

      - name: Setup environment
        run: |
          sudo timedatectl set-timezone "$TZ"
          mkdir -p ~/pack
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"

      - name: Update all packages
        run: |
          PACKAGES=(
            '3proxy' 'ShadowVPN' 'aardvark-dns' 'acme-acmesh' 'acme-common' 'acme'
            'adblock-fast' 'adblock' 'addrwatch' 'adguardhome' 'aggregate' 'aircrack-ng'
            'ampr-ripd' 'amule' 'announce' 'antiblock' 'apache' 'apcupsd' 'apfree-wifidog'
            'apinger' 'aria2' 'ariang' 'arp-scan' 'atftp' 'atlas-probe' 'atlas-sw-probe'
            'autossh' 'banip' 'basicstation' 'bcp38' 'beanstalkd' 'bfdd' 'bind' 'bitlbee'
            'bitsrunlogin-go' 'bmon' 'boinc-wrapper' 'boinc' 'bonding' 'bpfcountd' 'bridge-utils'
            'brook' 'bwm-ng' 'bwping' 'cdnspeedtest' 'cgi-io' 'chaosvpn' 'chinadns-ng'
            'chrony' 'cifs-utils' 'clamav' 'cloudflared' 'cloudreve' 'cni-route-override'
            'conntrack-tools' 'conserver' 'coova-chilli' 'croc' 'crowdsec-firewall-bouncer'
            'crowdsec' 'cshark' 'csshnpd' 'curl' 'daedae' 'daed' 'dante' 'darkstat' 'databag'
            'davfs2' 'dawn' 'dcstadt' 'dcwapd' 'ddns-go' 'ddns-scripts' 'ddns-scripts_dnspod'
            'dhcpcd' 'dhtd' 'dmapd' 'dns-over-https' 'dns2socks' 'dns2tcp' 'dnscrypt-proxy'
            'dnscrypt-proxy2' 'dnsdist' 'dnsforwarder' 'dnslookup' 'dnsproxy' 'dnstap' 'dnstop'
            'dufs' 'dynapoint' 'eoip' 'esniper' 'esp2net' 'etebase' 'etherwake-nfqueue'
            'etherwake' 'evilginx2' 'external-protocol' 'fail2ban' 'fakeidentd' 'fakepop'
            'family-dns' 'fastd' 'flent' 'foolsm' 'fping' 'freeradius3' 'frp' 'frr' 'fsh'
            'fwknop' 'gateway-go' 'gatling' 'gensio' 'geoip-shell' 'geoipupdate' 'geoview'
            'gg' 'git-lfs' 'git' 'gitolite' 'gnunet-fuse' 'gnunet' 'go-nats' 'go-wol' 'gost'
            'gsocket' 'haproxy' 'hcxdumptool' 'hcxtools' 'hev-socks5-server' 'hev-socks5-tproxy'
            'hev-socks5-tunnel' 'horst' 'hping3' 'hs20' 'htpdate' 'httping' 'https-dns-proxy'
            'httptunnel' 'hysteria' 'i2pd' 'ibrdtn-tools' 'ibrdtnd' 'ieee8021xclient' 'ifstat'
            'iftop' 'igmpproxy' 'inadyn' 'iodine' 'iperf' 'iperf3' 'ipset-lists' 'ipt2socks'
            'iptraf-ng' 'iputils' 'ipvsadm' 'irssi' 'irtt' 'isc-dhcp' 'jool' 'kadnode'
            'kafs-client' 'kcptun' 'kea' 'keepalived' 'knot-resolver' 'knot' 'knxd' 'kplex'
            'krb5' 'ksmbd-tools' 'lcdringer' 'leech' 'lftp' 'libcurl-gnutls' 'libndp'
            'librespeed-go' 'libreswan' 'lighttpd' 'linknx' 'linuxptp' 'lksctp-tools'
            'lora-gateway-hal' 'lynx' 'mac-telnet' 'maccalc' 'mbusd' 'mdio-tools' 'mdns-repeater'
            'mdnsresponder' 'memcached' 'microsocks' 'mikrotik-btest' 'mini_snmpd' 'minieap'
            'miniupnpc' 'miniupnpd' 'modemband' 'modemmanager' 'mosdns' 'mosh' 'mosquitto'
            'mptcpd' 'mrmctl' 'msd_lite' 'mtr' 'mwan3' 'n2n' 'naiveproxy' 'natmap' 'nbd'
            'ncp' 'nebula' 'net-mtools' 'net-snmp' 'net-tools' 'netatalk' 'netavark' 'netbird'
            'netcat' 'netdiscover' 'netifyd' 'netopeer2' 'netperf' 'netsniff-ng' 'netstinky'
            'nextdns' 'nexttrace' 'nfdump' 'nfs-kernel-server' 'nginx-util' 'nginx' 'ngircd'
            'ngrokc' 'njit8021xclient' 'nlbwmon' 'nmap' 'nps' 'nqptp' 'nsd' 'ntpd' 'ntripcaster'
            'ntripclient' 'ntripserver' 'nut' 'obfs4proxy' 'ocserv' 'ola' 'onionshare-cli' 'oor'
            'open-app-filter' 'open-iscsi' 'open-isns' 'openappid' 'openconnect' 'openelp'
            'openfortivpn' 'openlist' 'openssh' 'openthread-br' 'opentracker' 'openvpn-easy-rsa'
            'openvpn' 'openvswitch' 'oscam' 'ostiary' 'overture' 'ovn' 'ovsd' 'owipcalc' 'p910nd'
            'pagekitec' 'pandownload-fake-server' 'pbr' 'pdns-recursor' 'pdns' 'pen' 'phantap'
            'phytool' 'pingcheck' 'pixiewps' 'pppossh' 'pptpd' 'privoxy' 'prosody' 'proxychains-ng'
            'ps3netsrv' 'ptunnel-ng' 'qq' 'qBittorrent-Enhanced-Edition' 'qcsuper' 'quectel-cm'
            'radicale' 'radicale2' 'radius-mac' 'radsecproxy' 'ratched' 'ratechecker' 'ratelimit'
            'rclone-ng' 'rclone-webui-react' 'rclone' 'reaver' 'redsocks' 'redsocks2' 'remserial'
            'respondd' 'restic-rest-server' 'rp-pppoe' 'rpcbind' 'rsync' 'rtorrent' 'rustdesk-server'
            'safe-search' 'samba4' 'samplicator' 'scapy' 'scutclient' 'ser2net' 'shadow-tls'
            'shadowsocks-rust' 'shadowsocksr-libev' 'shorewall-core' 'shorewall-lite' 'shorewall'
            'shorewall6-lite' 'shorewall6' 'siit' 'simple-captive-portal' 'simple-obfs' 'sing-box'
            'slirp4netns' 'smartdns' 'smcroute' 'snort3' 'snowflake' 'socat' 'softethervpn'
            'softethervpn5' 'softflowd' 'spawn-fcgi' 'speedtest-cli' 'speedtest-go' 'speedtest-netperf'
            'speedtestcpp' 'spoofer' 'sqm-scripts' 'squid' 'srelay' 'sscep' 'sshfs' 'sshtunnel'
            'sslh' 'sstp-client' 'static-neighbor-reports' 'strongswan' 'stubby' 'stunnel' 'sub-web'
            'subconverter' 'subversion' 'switchdev-poller' 'sysrepo' 'sysuh3c' 'tac_plus' 'tailscale'
            'tayga' 'tcping' 'tcpproxy' 'tcpreplay' 'telnet-bsd' 'tgt' 'tinc' 'tinyfecvpn'
            'tinyportmapper' 'tinyproxy' 'tmate-ssh-server' 'tmate' 'tor-hs' 'tor' 'torsocks'
            'trafficshaper' 'transfer' 'transmission-web-control' 'transmission' 'travelmate' 'trojan'
            'tuic-client' 'tuic-server' 'tunneldigger-broker' 'tunneldigger' 'u2pnpd' 'ua2f' 'uacme'
            'uanytun' 'udhcpsnoop' 'udp-broadcast-relay-redux-openwrt' 'udp2raw' 'udphp-client'
            'udpspeeder' 'udptunnel' 'udpxy' 'ulogd' 'umurmur' 'unbound' 'uradvd' 'usbip' 'uspot'
            'usteer' 'uwsgi' 'v2ray-core' 'v2ray-geodata' 'v2ray-plugin' 'v2raya' 'vallumd' 'vlmcsd'
            'vnstat' 'vnstat2' 'vpnc-scripts' 'vpnc' 'vsftpd' 'wakeonlan' 'wavemon' 'webui-aria2'
            'wfb-ng' 'wg-installer' 'wget' 'wgsd' 'wifi-presence' 'wifidog' 'wifischedule' 'wsdd2'
            'xfrpc' 'xinetd' 'xl2tpd' 'xray-core' 'xray-plugin' 'xtables-addons' 'yggdrasil-jumper'
            'yggdrasil' 'zerotier' 'znc' 'ztdns'
          )
          
          UPDATED_COUNT=0
          FAILED_COUNT=0
          SKIPPED_COUNT=0
          
          # Add set -e to make the script exit immediately if a command fails
          set -e
          
          for package in "${PACKAGES[@]}"; do
            echo "======================================"
            echo "Processing: $package"
            echo "======================================"
            
            # Check if package directory exists
            if [ ! -d "$GITHUB_WORKSPACE/$package" ]; then
              echo "⚠️  Directory not found for $package, skipping..."
              ((SKIPPED_COUNT++))
              continue
            fi
            
            cd "$GITHUB_WORKSPACE/$package"
            
            # Check if Makefile exists
            if [ ! -f "Makefile" ]; then
              echo "⚠️  Makefile not found for $package, skipping..."
              ((SKIPPED_COUNT++))
              continue
            fi
            
            # Extract current version from Makefile
            CURRENT_VERSION=$(grep -E '^PKG_VERSION:=|^PKG_VERSION ?:=' Makefile 2>/dev/null | head -1 | sed 's/PKG_VERSION[[:space:]]*:=[[:space:]]*//' | tr -d ' ')
            
            if [ -z "$CURRENT_VERSION" ]; then
              echo "⚠️  Could not extract version for $package, skipping..."
              ((SKIPPED_COUNT++))
              continue
            fi
            
            echo "Current version: $CURRENT_VERSION"
            
            # Extract PKG_SOURCE_URL from Makefile to get the real GitHub repo
            SOURCE_URL=$(grep -E '^PKG_SOURCE_URL:=|^PKG_SOURCE_URL ?:=' Makefile 2>/dev/null | head -1 | sed 's/PKG_SOURCE_URL[[:space:]]*:=[[:space:]]*//')
            
            if [ -z "$SOURCE_URL" ]; then
              echo "⚠️  Could not extract source URL for $package, skipping..."
              ((SKIPPED_COUNT++))
              continue
            fi
            
            echo "Source URL: $SOURCE_URL"
            
            # Extract GitHub repo from URL (support multiple formats)
            GITHUB_REPO=""
            if [[ "$SOURCE_URL" =~ github\.com[:/]([^/]+/[^/]+) ]]; then
              GITHUB_REPO="${BASH_REMATCH[1]}"
              GITHUB_REPO="${GITHUB_REPO%.git}"
            fi
            
            if [ -z "$GITHUB_REPO" ]; then
              echo "⚠️  Not a GitHub source or cannot parse repo for $package, skipping..."
              ((SKIPPED_COUNT++))
              continue
            fi
            
            echo "GitHub repo: $GITHUB_REPO"
            
            # Try to get latest version from GitHub API
            LATEST_VERSION=""
            
            # Method 1: Try releases/latest
            LATEST_VERSION=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/$GITHUB_REPO/releases/latest" 2>/dev/null | \
              grep '"tag_name":' | head -1 | cut -d'"' -f4 | sed 's/^v//') || true
            
            # Method 2: If no release, try tags
            if [ -z "$LATEST_VERSION" ]; then
              LATEST_VERSION=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
                "https://api.github.com/repos/$GITHUB_REPO/tags" 2>/dev/null | \
                grep '"name":' | head -1 | cut -d'"' -f4 | sed 's/^v//') || true
            fi
            
            if [ -z "$LATEST_VERSION" ]; then
              echo "⚠️  Could not fetch latest version for $package"
              ((SKIPPED_COUNT++))
              continue
            fi
            
            echo "Latest version: $LATEST_VERSION"
            
            # Compare versions
            if [ "$LATEST_VERSION" = "$CURRENT_VERSION" ]; then
              echo "✅ $package is up to date ($CURRENT_VERSION)"
              continue
            fi
            
            # Check if this is actually a newer version (simple string comparison)
            if [[ "$LATEST_VERSION" < "$CURRENT_VERSION" ]]; then
              echo "⚠️  Latest version ($LATEST_VERSION) seems older than current ($CURRENT_VERSION), skipping..."
              ((SKIPPED_COUNT++))
              continue
            fi
            
            echo "🔄 Update available: $CURRENT_VERSION -> $LATEST_VERSION"
            
            # Create backup of Makefile
            cp Makefile Makefile.backup
            
            # Update version in Makefile
            sed -i "s/^PKG_VERSION[[:space:]]*:=[[:space:]]*.*$/PKG_VERSION:=$LATEST_VERSION/" Makefile
            
            # Try to download and get hash
            cd ~/pack
            rm -rf "$package"
            mkdir -p "$package"
            cd "$package"
            
            DOWNLOAD_SUCCESS=false
            NEW_HASH=""
            
            # Build possible download URLs based on SOURCE_URL pattern
            DOWNLOAD_URLS=()
            
            # If SOURCE_URL contains \$(PKG_VERSION), replace it
            if [[ "$SOURCE_URL" =~ \$\(PKG_VERSION\) ]]; then
              BASE_URL="${SOURCE_URL//\$(PKG_VERSION)/$LATEST_VERSION}"
              DOWNLOAD_URLS+=("$BASE_URL")
            fi
            
            # Add standard GitHub archive URLs
            DOWNLOAD_URLS+=(
              "https://github.com/$GITHUB_REPO/archive/refs/tags/v$LATEST_VERSION.tar.gz"
              "https://github.com/$GITHUB_REPO/archive/refs/tags/$LATEST_VERSION.tar.gz"
              "https://codeload.github.com/$GITHUB_REPO/tar.gz/v$LATEST_VERSION"
              "https://codeload.github.com/$GITHUB_REPO/tar.gz/$LATEST_VERSION"
            )
            
            # Try each download URL
            for url in "${DOWNLOAD_URLS[@]}"; do
              echo "Trying: $url"
              if wget -q --timeout=30 --tries=2 -O source.tar.gz "$url" 2>/dev/null; then
                if [ -f source.tar.gz ] && [ -s source.tar.gz ]; then
                  NEW_HASH=$(sha256sum source.tar.gz | awk '{print $1}')
                  if [ -n "$NEW_HASH" ]; then
                    DOWNLOAD_SUCCESS=true
                    echo "✓ Downloaded successfully"
                    break
                  fi
                fi
              fi
            done
            
            cd "$GITHUB_WORKSPACE/$package"
            
            if [ "$DOWNLOAD_SUCCESS" = true ] && [ -n "$NEW_HASH" ]; then
              # Update hash in Makefile
              if grep -q "^PKG_HASH" Makefile; then
                sed -i "s/^PKG_HASH[[:space:]]*:=[[:space:]]*.*$/PKG_HASH:=$NEW_HASH/" Makefile
              elif grep -q "^PKG_MD5SUM" Makefile; then
                # Some packages might use MD5, skip hash update
                echo "⚠️  Package uses MD5SUM, skipping hash update"
              fi
              
              # Commit changes
              git add Makefile
              
              if ! git diff --staged --quiet; then
                git commit -m "$package: update to $LATEST_VERSION" || true
                echo "✅ Updated $package to $LATEST_VERSION"
                ((UPDATED_COUNT++))
              else
                echo "⚠️  No changes detected after update"
                ((SKIPPED_COUNT++))
              fi
              
              # Remove backup
              rm -f Makefile.backup
            else
              echo "❌ Could not download source for $package $LATEST_VERSION"
              # Restore from backup
              mv Makefile.backup Makefile
              ((FAILED_COUNT++))
            fi
            
            cd "$GITHUB_WORKSPACE"
          done
          
          echo "======================================"
          echo "Summary:"
          echo "✅ Updated packages: $UPDATED_COUNT"
          echo "❌ Failed packages: $FAILED_COUNT"
          echo "⚠️  Skipped packages: $SKIPPED_COUNT"
          echo "======================================"

      - name: Push all changes
        run: |
          git pull --rebase origin main
          git push
